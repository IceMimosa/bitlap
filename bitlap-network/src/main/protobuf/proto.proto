syntax = "proto3";

option java_package = "org.bitlap.network.driver";
option java_multiple_files = true;

// OpenSession()
//
// Open a session (connection) on the server against which operations may be executed.
message BOpenSession {
  message BOpenSessionReq {
    // Username and password for authentication.
    // Depending on the authentication scheme being used,
    // this information may instead be provided by a lower
    // protocol layer, in which case these fields may be left unset.
    string username = 1;
    string password = 2;
    // Configuration overlay which is applied when the session is first created.
    map<string, string> configuration = 3;
  }
  message BOpenSessionResp {
    BStatus status = 1;
    // The configuration settings for this session.
    map<string, string>  configuration = 2;
    // Session Handle
    BSessionHandle session_handle = 3;
  }
}

// CloseSession()
//
// Closes the specified session and frees any resources currently allocated to that session. Any open
// operations in that session will be canceled.
message BCloseSession {
  message BCloseSessionReq {
    BSessionHandle session_handle = 1;
  }
  message BCloseSessionResp {
    BStatus status = 1;
  }
}

// ExecuteStatement()
//
// Execute a statement.
// The returned OperationHandle can be used to check on the
// status of the statement, and to fetch results once the statement has finished executing.
message BExecuteStatement {
  message BExecuteStatementReq {
    // The statement to be executed (DML, DDL, SET, etc)
    string statement = 1;
    // The session to execute the statement against
    BSessionHandle session_handle = 2;
    // Configuration properties that are overlayed on top of the
    // the existing session configuration before this statement
    // is executed. These properties apply to this statement
    // only and will not affect the subsequent state of the Session.
    map<string, string> conf_overlay = 3;
    // The number of seconds after which the query will timeout on the server
    int64 query_timeout = 4;// default 0
  }
  message BExecuteStatementResp {
    BStatus status = 1;
    BOperationHandle operation_handle = 2;
  }
}

// FetchResults()
//
// Fetch rows from the server corresponding to a particular OperationHandle.
message BFetchResults {
  message BFetchResultsReq {
    // Operation from which to fetch results.
    BOperationHandle operation_handle = 1;
    // Max number of rows that should be returned in
    // the rowset.
    int64 max_rows = 2;
    // The type of a fetch results request. 0 represents Query output. 1 represents Log
    int32 fetch_type = 3;
  }
  message BFetchResultsResp {
    BStatus status = 1;
    // TRUE if there are more rows left to fetch from the server.
    bool has_more_rows = 2;
    // The rowset. This is  so that we have the
    // option in the future of adding alternate formats for
    // representing result set data, e.g. delimited strings,
    // binary encoded, etc.
    BRowSet results = 3;
  }
}

// The return status code contained in each response.
enum BStatusCode {
  B_STATUS_CODE_SUCCESS_STATUS = 0;
  B_STATUS_CODE_STILL_EXECUTING_STATUS = 1;
  B_STATUS_CODE_ERROR_STATUS = 2;
  B_STATUS_CODE_INVALID_HANDLE_STATUS = 3;
  // TODO others
}

// The return status of a remote request
message BStatus {
  BStatusCode status_code = 1;
  // If status is ERROR, then the following fields may be set
  string sql_state = 2;  // as defined in the ISO/IEF CLI specification
  int32 error_code = 3;  // internal error code
  string error_message = 4;
}

message BHandleIdentifier {
  // 16 byte globally unique identifier
  // This is the public ID of the handle and
  // can be used for reporting.
  bytes guid = 1;
  // 16 byte secret generated by the server
  // and used to verify that the handle is not
  // being hijacked by another user.
  bytes secret = 2;
}

// Client-side handle to persistent
// session information on the server-side.
message BSessionHandle {
  BHandleIdentifier session_id = 1;
}

// Client-side reference to a task running
// asynchronously on the server.
message BOperationHandle {
  BHandleIdentifier operation_id = 1;
  BOperationType operation_type = 2;

  // If hasResultSet = TRUE, then this operation
  // generates a result set that can be fetched.
  // Note that the result set may be empty.
  //
  // If hasResultSet = FALSE, then this operation
  // does not generate a result set, and calling
  // GetResultSetMetadata or FetchResults against
  // this OperationHandle will generate an error.
  bool has_result_set = 3;

  // For operations that don't generate result sets,
  // modifiedRowCount is either:
  //
  // 1) The number of rows that were modified by
  //    the DML operation (e.g. number of rows inserted,
  //    number of rows deleted, etc).
  //
  // 2) 0 for operations that don't modify or add rows.
  //
  // 3) < 0 if the operation is capable of modifiying rows,
  //    but bitlap is unable to determine how many rows were
  //    modified. For example, bitlap's LOAD DATA command
  //    doesn't generate row count information because
  //    bitlap doesn't inspect the data as it is loaded.
  //
  // modifiedRowCount is unset if the operation generates
  // a result set.
  double modified_row_count = 4;
}

// The subtype of an OperationHandle.
enum BOperationType {
  B_OPERATION_TYPE_UNSPECIFIED = 0;
  B_OPERATION_TYPE_EXECUTE_STATEMENT = 1;
  B_OPERATION_TYPE_GET_SCHEMAS = 2;
  B_OPERATION_TYPE_GET_TABLES = 3;
  B_OPERATION_TYPE_GET_COLUMNS = 4;
}

// Metadata used to describe the schema (column names, types, comments)
// of result sets.
message BTableSchema {
  repeated BColumnDesc columns = 1;
}

// A result set column descriptor.
message BColumnDesc {
  // The name of the column
  string column_name = 1;
  // The type descriptor for this column
  BTypeId type_desc = 2; //TODO
}

// Represents a row in a rowset.
message BRow {
  repeated bytes col_vals = 1;
}

// Represents a rowset
message BRowSet {
  // The starting row offset of this rowset.
  int64 start_row_offset = 1;
  repeated BRow rows = 2;
  repeated BColumn columns = 3;
}

message BColumn {
  // TODO pb does not support inheritance?
  repeated string string_column = 1;
}

// GetSchemas()
//
// Retrieves the schema names available in this database.
// The results are ordered by TABLE_CATALOG and TABLE_SCHEM.
// col1
// name: TABLE_SCHEM
// type: STRING
// desc: schema name
// col2
// name: TABLE_CATALOG
// type: STRING
// desc: catalog name
message BGetSchemas {
  message BGetSchemasReq {
    // Session to run this request against
    BSessionHandle session_handle = 1;
    // Name of the catalog. Must not contain a search pattern.
    string  catalog_name = 2;
    // schema name or pattern
    string  schema_name = 3;
  }

  message BGetSchemasResp {
    BStatus status = 1;
    BOperationHandle operation_handle = 2;
  }
}

// GetTables()
//
// Returns a list of tables with catalog, schema, and table
// type information. The information is returned as a result
// set which can be fetched using the OperationHandle
// provided in the response.
// Results are ordered by TABLE_TYPE, TABLE_CAT, TABLE_SCHEM, and TABLE_NAME
//
// Result Set Columns:
//
// col1
// name: TABLE_CAT
// type: STRING
// desc: Catalog name. NULL if not applicable.
//
// col2
// name: TABLE_SCHEM
// type: STRING
// desc: Schema name.
//
// col3
// name: TABLE_NAME
// type: STRING
// desc: Table name.
//
// col4
// name: TABLE_TYPE
// type: STRING
// desc: The table type, e.g. "TABLE", "VIEW", etc.
//
// col5
// name: REMARKS
// type: STRING
// desc: Comments about the table
//
message BGetTables {
  message BGetTablesReq {
    // Session to run this request against
    BSessionHandle session_handle = 1;
    // Name of the schema or a search pattern.
    string  schema_name = 2;
    // Name of the table or a search pattern.
    string  table_name = 3;
  }

  message BGetTablesResp {
    BStatus status = 1;
    BOperationHandle operation_handle = 2;
  }
}

// GetColumns()
//
// Returns a list of columns in the specified tables.
// The information is returned as a result set which can be fetched
// using the OperationHandle provided in the response.
// Results are ordered by TABLE_CAT, TABLE_SCHEM, TABLE_NAME,
// and ORDINAL_POSITION.
//
// Result Set Columns are the same as those for the ODBC CLIColumns
// function.
//
message BGetColumns {
  message BGetColumnsReq {
    // Session to run this request against
    BSessionHandle session_handle = 1;
    // Schema name or search pattern
    string  schema_name = 2;
    // Table name or search pattern
    string  table_name = 3;
    // Column name or search pattern
    string  column_name = 4;
  }

  message BGetColumnsResp {
    BStatus status = 1;
    BOperationHandle operation_handle = 2;
  }

}

// GetResultSetMetadata()
//
// Retrieves schema information for the specified operation
message BGetResultSetMetadata {
  message BGetResultSetMetadataReq {
    // Operation for which to fetch result set schema information
    BOperationHandle operation_handle = 1;
  }

  message BGetResultSetMetadataResp {
    BStatus status = 1;
    BTableSchema schema = 2;
  }

}

enum BTypeId {
  B_TYPE_ID_UNSPECIFIED = 0;
  B_TYPE_ID_STRING_TYPE = 1;
  B_TYPE_ID_INT_TYPE = 2;
  B_TYPE_ID_DOUBLE_TYPE = 3;
  B_TYPE_ID_LONG_TYPE = 4;
  B_TYPE_ID_BOOLEAN_TYPE = 5;
  B_TYPE_ID_TIMESTAMP_TYPE = 6;
  B_TYPE_ID_SHORT_TYPE = 7;
  B_TYPE_ID_BYTE_TYPE = 8;
}


message BGetRaftMetadata {
  message BGetLeaderReq {
    string  request_id = 1;
  }
  message BGetLeaderResp {
    optional string  ip = 1;
    uint32  port = 2;
  }
}